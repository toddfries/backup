#!/bin/ksh

# Copyright (c) 2012 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# for now, local restores until experience is built up

filetype() {
	local f="$1"
	if [ "$(dd bs=3 count=1 if="$f" 2> /dev/null | hexdump -C| \
		grep -v "00000000  5d 00 00")" ]; then
		echo lzma
		return
	fi
	fileinfo=$(file "$f" 2> /dev/null)
	case "$fileinfo" in
	*"gzip compressed data"*) echo gzip;;
	esac
}

decomp() {
	local f="$1"
	ftinfo="$(filetype "$f")"
	case "$ftinfo" in
	lzma) lzma -d < "$f";;
	gzip) gzip -d < "$f";;
	*) echo "Unknown filetype of $f: $ftinfo";;
	esac
}

verbose=0
while [ "$1" ]
do
	case "$1" in
	-v) ((verbose++));;
	-i) ignores[${#ignores[*]}]="$2"; shift;;
	*) break;;
	esac
	shift
done
usage() {
	echo "Usage: $0 backupsetname backupdir"
	exit $1
}

setname="$1"
if ! [ "$setname" ]; then
	usage 1
fi

# backup directory
bkd="/etc/backup/$setname"
if ! [ -d "$bkd" ]; then
	echo "$bkd directory does not exist!"
	exit 2
fi
if [ -f "$bkd/conf" ]; then
	. $bkd/conf
fi
if ! [ -d "$datadir/$(hostname)" ]; then
	echo "$datadir/$(hostname) in $bkd/conf does not exist!"
	exit 3
fi
cd $datadir/$(hostname)
subdir="$2"
if ! [ "$subdir" -a -d "$subdir" ]; then
	usage 4
fi
finddir=$(df -P $subdir | awk '/^Filesystem/{next}{print $6}')
fpat=$(echo "$subdir" | sed 's,//,,;s,[/:],_,g')

td=$(mktemp -d $subdir/vault-restore.XXXXXXXXXXXXXXXXXXXX)

if ((verbose > 0)); then
	set -x
fi

set -A files *_${fpat}.?.filelist
for f in ${files[*]}
do
	[ -e "$f" ] || continue
	echo "Processing $f" > /dev/tty
	decomp "$f"
done | awk '/^(Verify tape|Dump   date|Dumped from|Extract directories|Initialize symbol table)/{next} {sub("^\./","",$2);$1 = ""; print}' | \
sort -u | \
while read f
do
	ign=0
	while [ ign -lt ${#ignores[*]} ]
	do
		if [[ $f == *${ignores[$ign]}* ]]; then
			continue 2
		fi
		((ign++))
	done
	[ -e "$finddir/$f" ] || echo "$f"
done > $td/restlist
EDITOR=${EDITOR:-vi}
$EDITOR $td/restlist
[ -s $td/restlist ] || exit 1
for f in ${files[*]}
do
	decomp "$f" | while read ino name
	do
		rfile=$(egrep "^${name#./}" $td/restlist)
		if [ "$rfile" ]; then
			echo "$f $rfile" >> $td/rfilelist
		fi
	done
done
restfiles() {
	egrep "^[^ ]+ $1$" $td/rfilelist | awk '{print $1}' | sort -u
}
for f in $(sort -u $td/rfilelist | awk '{$1="";print}')
do
	echo "$(/bin/ls -1t $(restfiles "$f") | head -1) ./$f"
done > $td/restorelist
mkdir $td/restdir
echo "Restored files will be in $td/restdir"
for file in $(awk '{sub("\.filelist$","",$1); print $1}' < $td/restorelist | sort -u)
do
	arglist="$(grep "^$file" < $td/restorelist | \
	    awk '{$1 = ""; print $0}')"
	if [ "$arglist" ]; then
		echo "Extracting from $file"
		decomp "$file" | (
			cd $td/restdir
			time restore -xvyf - $arglist
		)
	fi
done
