#!/bin/sh

# Copyright (c) 2001-2007 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# Tower of Hanoi
# 0 2 1 4 3 6 5 8 7 8 9 <-- backup level
# x 6 0 1 2 3 4 5       <-- day of week

# The `Tower of Hanoi' would be keeping multiple redundant copies of data,
# but require multiple recoveries in the event something needed to be
# recovered.

# The below does no redundant copies and only requires two restores max
# recover any lost data, and archives one month prior of a full backup

# 0 / 7 is Sunday

user=$(awk -v id=`id -u` -F: '$3 == id {print $1}' /etc/passwd)
if [ "$user" != "_backup" ]; then
	echo "This script should only be run as user _backup"
	exit 1
fi

if ! [ "$1" ]; then
	echo "Usage: $0 backupsetname"
	exit 2
fi

# backup directory
bkd="/etc/backup/$1"

if ! [ -d "$bkd" ]; then
	echo "$bkd directory does not exist!"
	exit 3
fi
if ! [ -f "$bkd/dumplist" ]; then
	echo "$bkd/dumplist file does not exist!"
	exit 4
fi
if [ -f "$bkd/conf" ]; then
	. $bkd/conf
fi

if [ -d "$datadir" ]; then
	cd $datadir
else
	echo "$datadir in $bkd/conf does not exist!"
	exit 5
fi

goodsummary() {
	size=$(($(stat -f%z "$outfile")+0))
	ucsize=$(($($aprog -d < "$outfile" | wc -c)+0))
	unit=B
	if [ size -gt 1000 -a ucsize -gt 1000 ]; then
		size="$(echo "scale=5;$size/1024"|bc)"
		ucsize="$(echo "scale=5;$ucsize/1024"|bc)"
		unit=KB
	fi
	if [ ${size%.*} -gt 1000 -a ${ucsize%.*} -gt 1000 -a $unit = "KB" ]; then
		size="$(echo "scale=5;$size/1024"|bc)"
		ucsize="$(echo "scale=5;$ucsize/1024"|bc)"
		unit=MB
	fi
	if [ ${size%.*} -gt 1000 -a ${ucsize%.*} -gt 1000 -a $unit = "MB" ]; then
		size="$(echo "scale=5;$size/1024"|bc)"
		ucsize="$(echo "scale=5;$ucsize/1024"|bc)"
		unit=GB
	fi
	comp=$(echo "scale=2;100*$size/$ucsize"|bc)
	ratio=$(echo "scale=2;100-$comp"|bc)
	printf "%.2f$unit -> %.2f$unit, compressed ${comp}%%, ratio $ratio%%\n" $ucsize $size
	printf "Took %ds, %.2f$unit/s -> %.2f$unit/s, %s -> %s\n" \
	    $((stop-start)) \
	    $(echo "scale=2;$ucsize/($stop-$start)"|bc) \
	    $(echo "scale=2;$size/($stop-$start)"|bc) \
	    "$(date -r $start)" \
	    "$(date -r $stop)"
	return 0
}

# weekdays    0 1 2 3 4 5 6 7
set -A levels 6 5 4 3 2 1 7 6

echo "Starting $0.. $@"

dayofweek=$(date +%w)
l=${levels[$dayofweek]}

m=$( date +%d )

if false; then
# do a full backup monthly and keep an older copy around
case "$m" in
01|1)
        l=0
        echo "1st day of month -> level $l"
        rotate() {
                mv "$1" "$1".0
        }
;;
*)
        echo "Weekday $d -> level $l"
        rotate() {
                :
        }
;;
esac
fi


for f in $(sed 's/#.*$//;/^$/d' $bkd/dumplist)
do
	thisl=$l
	case "$f" in
	sshsmb*)
		eval $(echo "$f" | sed 's,sshsmb://\([^@]*\)@\([^/]*\)/\([^@]*\)@\([^/]*\)/\(.*\)$,sshuser=\1 sshhost=\2 smbauth=\3 smbhost=\4 smbshare=\5,')
		host=$sshhost
		auth=$bkd/${sshhost}_${smbhost}smbauth$smbauth
		smbshare="$(echo "$smbshare"|sed 's/%SPACE%/ /g')"
		f="${sshhost}-${smbhost}_${smbshare}"
		backupmethod() {
			scmd="ssh $sshxtra -C "
			if [ -f $bkd/${sshhost}_sshconfig ]; then
				scmd="$scmd -F $bkd/${sshhost}_sshconfig "
			fi
			authkey=$bkd/${sshhost}_sshkey
			scmd="$scmd -i $authkey "
			scmd="$scmd $sshuser@$sshhost "

			cmd="/usr/local/bin/smbclient -d2 -E -A%s //$smbhost/$smbshare -D / -c 'tarmode full' -Tc%s %s -"
			printf "$cmd" $auth $nopt "$nfil" > /dev/stderr
			{
				echo "d=\$(mktemp -d /tmp/.smbbackup.XXXXXXXXXX)"
				echo "cd \$d"
				if [ "$nfil" ]; then
					echo "touch -t \"$(date -r $(stat -f%c "$nfil") +"%Y%m%d%H%M.%S")\" timestamp"
					smbfile="timestamp"
				else
					smbfile=""
				fi
				echo "cat<<EOF>smbauth"
				cat $auth
				echo EOF
				printf "$cmd" smbauth $nopt $smbfile
				#echo "rm -rf \$d"
			} | $scmd sh
		}
		listmethod() {
			tar tvzf "$outfile" | \
				awk '/drwx/ { next } \
				    { \
					$1=$2=$3=$4=$5=$6=$7=$8=""; \
					gsub("/","\\"); \
					print }' | sed 's/^[ ]*\./\\tmp/' 
		}
	;;
	smb*)
		host=$(echo "$f" | sed 's,smb://.*@\([^/]*\)/.*$,\1,')
		auth=$bkd/${host}_smbauth$(echo "$f" | sed 's,smb://\([^@]*\)@.*$,\1,')
		f=$(echo "$f" | sed 's/%SPACE%/ /g;s,smb://[^@]*@\([^/]*\)/\(.*\)$,//\1/\2,')
		file="$(echo "$f" | sed 's,//[^/]*/\(.*\)$,\1,')"
		smbshare="$(echo "$f" | sed 's,//[^/]*/\([^/]*\).*$,\1,')"
		smbsubdir="$(echo "$f" | sed 's,//[^/]*/[^/]*\(/.*$\),\1,')"
		[ "$smbsubdir" ] || smbsubdir="/"
		#echo "host=\"$host\" smbshare=\"$smbshare\" subdir=\"$smbsubdir\""
		backupmethod() {
			echo "smbclient -d2 -E -A$auth \"//$host/$smbshare\" -D \"$smbsubdir\" -c 'tarmode full' -Tc$nopt \"$nfil\" -" > /dev/stderr
			smbclient -d2 -E -A$auth "//$host/$smbshare" -D "$smbsubdir" \
				-c 'tarmode full' -Tc$nopt "$nfil" - 
		}
		listmethod() {
			tar tvzf "$outfile" | \
				awk '/drwx/ { next } \
				    { \
					$1=$2=$3=$4=$5=$6=$7=$8=""; \
					gsub("/","\\"); \
					print }' | sed 's/^[ ]*\./\\tmp/' 
		}
	;;
	dump*) # dump://host/sub/dir/or/device
		host=$(echo "$f" | sed 's,dump://\([^/]*\)/.*$,\1,')
		file=$(echo "$f" | sed 's,dump://[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			cmd="dump -h 0 "
			if [ "$nfil" ]; then
				cmd="$cmd -T \"\$(date -r $(stat -f%c "$nfil") +"%a %b %e %H:%M:%S %Y")\" "
			fi
			cmd="$cmd -0a -f - $file"
			echo "$cmd" > /dev/stderr
			#set -x
			$cmd
		}
		listmethod() {
			gzip -d < "$outfile" | restore -tvf - | \
				awk '	/^dir/	{next} \
					/leaf/	{ $1="";print} \
						{print}'
		}
	;;
	sshdump*) # sshdump://user@host/sub/dir/or/device
		host=$(echo "$f" | sed 's,sshdump://.*@\([^/]*\)/.*$,\1,')
		authkey=$bkd/${host}_sshkey
		authuser=$(echo "$f" | sed 's,sshdump://\(.*\)@.*$,\1,')
		file=$(echo "$f" | sed 's,sshdump://.*@[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			cmd="ssh $sshxtra -C "
			if [ -f $bkd/${host}_sshconfig ]; then
				cmd="$cmd -F $bkd/${host}_sshconfig "
			fi
			cmd="$cmd -i $authkey "
			cmd="$cmd $authuser@$host "
			cmd="$cmd dump -h 0 "
			if [ "$nfil" ]; then
				cmd="$cmd -T \"$(date -r $(stat -f%c "$nfil") +"%a %b %e %H:%M:%S %Y")\" "
			fi
			cmd="$cmd -0a -f - $file"
			echo "$cmd" > /dev/stderr
			#set -x
			$cmd
		}
		listmethod() {
			gzip -d < "$outfile" | restore -tvf - | \
				awk '	/^dir/	{next} \
					/leaf/	{ $1="";print} \
						{print}'
		}
	;;
	sshafs*) # sshafs://user@host/afsvolume
		host=$(echo "$f" | sed 's,sshafs://.*@\([^/]*\)/.*$,\1,')
		authkey=$bkd/${host}_sshkey
		authuser=$(echo "$f" | sed 's,sshafs://\(.*\)@.*$,\1,')
		vol=$(echo "$f" | sed 's,sshafs://.*@[^/]*/\(.*\)$,\1,')
		f="$host:$vol"
		backupmethod() {
			cmd="ssh $sshxtra -C "
			if [ -f $bkd/${host}_sshconfig ]; then
				cmd="$cmd -F $bkd/${host}_sshconfig "
			fi
			cmd="$cmd -i $authkey "
			cmd="$cmd $authuser@$host "
			cmd="$cmd /usr/local/sbin/vos dump $vol "
			if [ "$nfil" ]; then
				cmd="$cmd -time \"$(date -r $(stat -f%c "$nfil") +"%m/%d/%Y %H:%M")\" "
			fi
			cmd="$cmd -verbose -localauth"
			echo "$cmd" > /dev/stderr
			$cmd
		}
		listmethod() {
			echo "No listing for sshafs implemented yet"
		}
	;;
	esac
	[ -d $host ] || mkdir $host
	fn="$(echo "$f" | sed 's,//,,;s,[/:],_,g')"

	# Do level `0' if it does not already exist
	[ -f "$host/$fn.0" -a -f "$host/$fn.0.timestamp" ] || thisl=0

	high=-1
	tmp=-1
	nopt=""
	nfil=""
	#echo "$f calculating level: req/high/tmp = $thisl/$high/$tmp"
	case $((thisl+0)) in
	0)
		nopt=""
		nfil=""
	;;
	1)
		nopt="N"
		nfil="$host/$fn.0.timestamp"
		lastl=0
	;;
	[2-9])
		# find the newest backup lower than the current level
		# and if there is a timestamp file, use it to backup to the
		# current level
		high=$((thisl-1))
		tmp=$((thisl-2))
		while [ tmp -ge 0 ]; do
			#echo "$f calculating level: req/high/tmp = $thisl/$high/$tmp"
			tmpfile="$host/${fn}.${tmp}.timestamp"
			highfile="$host/${fn}.${high}.timestamp"
			if [ -f "$tmpfile" -a -f "$highfile" ] && \
			    [ "$tmpfile" -nt "$highfile" ]; then
				high=$tmp
			fi
			let tmp=tmp-1
		done
		if [ -f "$host/$fn.$high.timestamp" ]; then
			nopt="N"
			nfil="$host/$fn.$high.timestamp"
			lastl=$high
		else
			if [ -f "$host/$fn.0.timestamp" ]; then
				nopt="N"
				nfil="$host/$fn.0.timestamp"
				lastl=0
			fi
		fi
		#echo "$f calculated level: req/high/tmp = $thisl/$high/$tmp"
	;;
	esac

	aprog=gzip
	aopt=9

	outfile="$fn.$thisl"
	start=$(date +%s)
	echo "$f"
	echo "Date of this level $thisl: $(date -r $start)"
	case "$thisl" in
	0)
	;;
	[1-9]*)
		echo "Date of last level $lastl: $(date -r $(stat -f%c "$nfil"))"
	;;
	esac
	tmpfile="$(mktemp "$datadir/$host/.$outfile.XXXXXXXXXXX")"
	outfile="$host/$outfile"
	touch "$tmpfile.timestamp"
	retrycount=0
	#echo "$tmpfile"
	#set -x
	while [ retrycount -lt 30 ]; do
	backupmethod 2> "$tmpfile.stderr" | \
		$aprog -$aopt > "$tmpfile" && \
		mv "$tmpfile" "$outfile" && \
		mv "$tmpfile.timestamp" "$outfile.timestamp" && \
		mv "$tmpfile.stderr" "$outfile.stderr" && \
		listmethod 2> /dev/null | $aprog -$aopt > "$outfile.filelist"
	if [ "$( tail "$outfile.stderr" | grep "no address associated" )" ]
	then
		echo "DNS failure for $f"
		echo "Retrying..."
		let retrycount=retrycount+1
		continue
	fi
	break
	done
	stop=$(date +%s)

	if [ "$( tail "$outfile.stderr" | grep "Connection reset by peer" )" ]
	then
		echo "Backup failed for $f -> $outfile"
		echo "Remote peer aborted early, removing backup"
		[ -f "$outfile.stderr" ] && cat "$outfile.stderr"
		rm "${outfile}"*
	fi

	if [ -f "$outfile" ]; then
		goodsummary
	else
		echo "Backup failed for $f -> $outfile"
		[ -f "$tmpfile.stderr" ] && cat "$tmpfile.stderr"
		rm "$tmpfile".*
	fi
	echo
done

# remotemirror should be of the form
#  mirror://user@host/subdir
if [ "$remotemirror" ]; then
	if [ "$(pgrep -u _backup rsync)" ]; then
		echo rsync already running
		exit 0
	fi
	user=$(echo $remotemirror|sed 's,mirror://\([^@]*\)@[^/]*/.*$,\1,')
	host=$(echo $remotemirror|sed 's,mirror://[^@]*@\([^/]*\)/.*$,\1,')
	dir=$(echo $remotemirror|sed 's,mirror://[^@]*@[^/]*\(/.*\)$,\1,')
	tmpfile=$(mktemp $datadir/.ssh.XXXXXXXXXXX)
	{
		echo "#!/bin/sh" 
		echo -n "ssh $sshxtra "
		if [ -f $bkd/${host}_sshkey ]; then
			echo -n "-i $bkd/${host}_sshkey "
		fi
		if [ -f $bkd/${host}_sshconfig ]; then
			echo -n "-F $bkd/${host}_sshconfig "
		fi
		echo "\"\$@\""
	} > $tmpfile
	chmod 755 $tmpfile
	/usr/local/bin/rsync -rtqz --partial --inplace --bwlimit=120 -e $tmpfile \
		--exclude=".*" $datadir/. $host:$dir
	rm $tmpfile
fi
