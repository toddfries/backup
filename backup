#!/usr/local/bin/ksh

# Copyright (c) 2001-2008 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

user=$(awk -v id=`id -u` -F: '$3 == id {print $1}' /etc/passwd)
if [ "$user" != "_backup" ]; then
	echo "This script should only be run as user _backup"
	exit 1
fi

if [ "$1" = "-r" ]; then
	# rsync only run
	shift
	rsynconly=1
else
	rsynconly=0
fi

if ! [ "$1" ]; then
	echo "Usage: $0 backupsetname"
	exit 2
fi

# Tower of Hanoi
# 0 2 1 4 3 6 5 8 7 8 9 <-- backup level
# x 6 0 1 2 3 4 5       <-- day of week

# The `Tower of Hanoi' would be keeping multiple redundant copies of data,
# but require multiple recoveries in the event something needed to be
# recovered.

# The below does no redundant copies and only requires two restores max
# recover any lost data, and archives one month prior of a full backup

#
# default over-ridable variables
#

# 0 / 7 is Sunday

# weekdays    0 1 2 3 4 5 6 7
set -A levels 6 5 4 3 2 1 7 6

# to do inc only and no redundancy
#set -A levels 3 4 5 6 7 1 2 3

outputstart=",--------------------------------------------"
outputstop="\`--------------------------------------------"
datefmt="%m/%d/%Y %H:%M:%S %Z"
successcookie="Success.$RANDOM"
maxretry=3
maxhist=0

# backup directory
bkd="/etc/backup/$1"

if ! [ -d "$bkd" ]; then
	echo "$bkd directory does not exist!"
	exit 3
fi
if ! [ -f "$bkd/dumplist" ]; then
	echo "$bkd/dumplist file does not exist!"
	exit 4
fi
if [ -f "$bkd/conf" ]; then
	. $bkd/conf
fi

if [ -d "$datadir" ]; then
	cd $datadir
else
	echo "$datadir in $bkd/conf does not exist!"
	exit 5
fi

#
# vars not overrideable
#

totsize=0
totucsize=0

bubble() {
	echo "$outputstart"
	cat
	echo "$outputstop"
}
setunit() {
	#set -x
	sone="$1"

	gunit="B "
	local a="$sone"
	if [ ${#a} -gt 3 ]; then
		sone="$(echo "scale=5;$sone/1024"|bc)"
		gunit=KB
	fi
	a="${sone%.*}"
	if [ ${#a} -gt 3 -a "$gunit" = "KB" ]; then
		sone="$(echo "scale=5;$sone/1024"|bc)"
		gunit=MB
	fi
	a="${sone%.*}"
	if [ ${#a} -gt 3 -a "$gunit" = "MB" ]; then
		sone="$(echo "scale=5;$sone/1024"|bc)"
		gunit=GB
	fi
	a="${sone%.*}"
	if [ ${#a} -gt 3 -a "$gunit" = "GB" ]; then
		sone="$(echo "scale=5;$sone/1024"|bc)"
		gunit=TB
	fi
	a="${sone%.*}"
	if [ ${#a} -gt 3 -a "$gunit" = "TB" ]; then
		sone="$(echo "scale=5;$sone/1024"|bc)"
		gunit=PB
	fi
}
detailsrun=0
savedetails() {
	#set -x
	local s="$1" ucs="$2" fs="$3" time="$4"
	local h m tmp comp ratio
	if [ s -eq 0 -a ucs -eq 0 ]; then
		comp=0
		ratio=0
	else
		comp=$(echo "scale=2;100*$s/$ucs"|bc)
		ratio=$(echo "scale=2;100-$comp"|bc)
	fi
	setunit $ucs
	ucunit="$gunit"
	ucsize="$sone"
	setunit $s
	unit="$gunit"
	size="$sone"
	h=$((time/3600))
	tmp=$((time - h*3600))
	m=$((tmp/60))
	s=$((tmp - m*60))
	[ detailsrun -eq 1 ] && details="$details\n"
	details="$details$(printf "%7.2f$ucunit %6.2f$ucunit" $ucsize $(echo "scale=2;$ucsize/$time"|bc) ) "
	details="$details$(printf "%7.2f$unit %6.2f$unit" $size   $(echo "scale=2;$size/$time"|bc) ) "
	details="$details$(printf "%6.2f %6.2f " $comp $ratio)"
	details="$details$(printf "%2d:%02d:%02d" $h $m $s) $fs"
	detailsrun=1
}

details=""
_log() {
	printf "%s %s\n" "$1" "$2"
}
log() {
	_log "$(date +"$datefmt")" "$@"
}

globalstart=$(date +%s)
_log "$(date -r $globalstart +"$datefmt")" "pid $$: backup of $@ set starting"

dayofweek=$(date +%w)
l=${levels[$dayofweek]}

m=$( date +%d )


rotate() {
	if [ maxhist -eq 0 ]; then
		return
	fi
	local max=$maxhist
	local down=0
	while [ max -gt 0 ]; do
		let down=max-1
		if [ -f "$1".$down ]; then
			mv "$1".$down "$1".$max
			mv "$1.timestamp.$down" "$1.timestamp.$max"
			mv "$1.stderr.$down" "$1.stderr.$max"
			mv "$1.filelist.$down" "$1.filelist.$max"
		fi
		let max=down
	done
	if [ -f "$1" ]; then
		mv $1           $1.0
		mv $1.timestamp $1.timestamp.0
		mv $1.stderr    $1.stderr.0
		mv $1.filelist  $1.filelist.0
	fi
}

smbclient=/usr/local/bin/smbclient

if [ rsynconly = 0 ]; then
for f in $(sed 's/#.*$//;/^$/d' $bkd/dumplist)
do
	thisl=$l
	case "$f" in
	sshsmb*)
		method=sshsmb
		eval $(echo "$f" | sed 's,sshsmb://\([^@]*\)@\([^/]*\)/\([^@]*\)@\([^/]*\)/\(.*\)$,sshuser=\1 sshhost=\2 smbauth=\3 smbhost=\4 smbshare=\5,')
		host=$sshhost
		auth=$bkd/${sshhost}_${smbhost}smbauth$smbauth
		smbshare="$(echo "$smbshare"|sed 's/%SPACE%/ /g')"
		f="${sshhost}-${smbhost}_${smbshare}"
		backupmethod() {
			scmd="ssh $sshxtra -C "
			if [ -f $bkd/${sshhost}_sshconfig ]; then
				scmd="$scmd -F $bkd/${sshhost}_sshconfig "
			fi
			authkey=$bkd/${sshhost}_sshkey
			scmd="$scmd -i $authkey "
			scmd="$scmd $sshuser@$sshhost "

			cmd="$smbclient -d2 -E -A%s //$smbhost/$smbshare -D / -c 'tarmode full' -Tc%s %s -"
			log "$cmd" $auth $nopt "$nfil" > /dev/stderr
			{
				echo "d=\$(mktemp -d /tmp/.smbbackup.XXXXXXXXXX)"
				echo "cd \$d"
				if [ "$nfil" ]; then
					echo "touch -t \"$(date -r $(stat -f%c "$nfil") +"%Y%m%d%H%M.%S")\" timestamp"
					smbfile="timestamp"
				else
					smbfile=""
				fi
				echo "cat<<EOF>smbauth"
				cat $auth
				echo EOF
				printf "$cmd" smbauth $nopt $smbfile
				#echo "rm -rf \$d"
			} | $scmd sh && echo $successcookie > /dev/stderr
		}
		listmethod() {
			tar tvzf "$outfile" | \
				awk '/drwx/ { next } \
				    { \
					$1=$2=$3=$4=$5=$6=$7=$8=""; \
					gsub("/","\\"); \
					print }' | sed 's/^[ ]*\./\\tmp/' 
		}
	;;
	smb*)
		method=smb
		host=$(echo "$f" | sed 's,smb://.*@\([^/]*\)/.*$,\1,')
		auth=$bkd/${host}_smbauth$(echo "$f" | sed 's,smb://\([^@]*\)@.*$,\1,')
		f=$(echo "$f" | sed 's/%SPACE%/ /g;s,smb://[^@]*@\([^/]*\)/\(.*\)$,//\1/\2,')
		file="$(echo "$f" | sed 's,//[^/]*/\(.*\)$,\1,')"
		smbshare="$(echo "$f" | sed 's,//[^/]*/\([^/]*\).*$,\1,')"
		smbsubdir="$(echo "$f" | sed 's,//[^/]*/[^/]*\(/.*$\),\1,;s,^//.*$,,')"
		[ "$smbsubdir" ] || smbsubdir="/"
		#echo "host=\"$host\" smbshare=\"$smbshare\" subdir=\"$smbsubdir\""
		backupmethod() {
			echo "smbclient -d2 -E -A$auth \"//$host/$smbshare\" -D \"$smbsubdir\" -c 'tarmode full' -Tc$nopt \"$nfil\" -" > /dev/stderr
			if [ "$nfil" ]; then
				$smbclient -d2 -E -A$auth "//$host/$smbshare" -D "$smbsubdir" \
					-c 'tarmode full' -Tc$nopt "$nfil" - && echo $successcookie > /dev/stderr
			else
				$smbclient -d2 -E -A$auth "//$host/$smbshare" -D "$smbsubdir" \
					-c 'tarmode full' -Tc  - && echo $successcookie > /dev/stderr
			fi
		}
		listmethod() {
			tar tvzf "$outfile" | \
				awk '/drwx/ { next } \
				    { \
					$1=$2=$3=$4=$5=$6=$7=$8=""; \
					gsub("/","\\"); \
					print }' | sed 's/^[ ]*\./\\tmp/' 
		}
	;;
	tar*) # tar://host/sub/dir/or/device
		method=tar
		host=$(echo "$f" | sed 's,tar://\([^/]*\)/.*$,\1,')
		file=$(echo "$f" | sed 's,tar://[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			# would like -O but FreeBSD doesn't have it, bah
			cmd="/bin/pax -Xwv "
			if [ "$nfil" ]; then
				cmd="$cmd -T $(date -r $(stat -f%c "$nfil") +"%Y%m%d%H%M.%S") "
			fi
			cmd="$cmd ."
			log "$cmd $file" > /dev/stderr
			#set -x
			if [ -d $file ]; then
				( cd $file; $cmd && echo $successcookie > /dev/stderr )
			else
				bd=$(dirname $file)
				if [ -d $bd ]; then
					( cd $bd; $cmd $(basename $file) && echo $successcookie > /dev/stderr )
				fi
			fi
		}
		listmethod() {
			gzip -d < "$outfile" | tar -tvf - | \
				awk '	/^d/	{next} \
					/^\-/	{ $1="";print} \
						{print}'
			if [ -f "${outfile}.stderr" ]; then
				if egrep "^pax: " "${outfile}.stderr" > /dev/null 2>&1; then
					egrep "^pax: " "${outfile}.stderr" | bubble > /dev/stderr
				fi
			fi
		}
	;;
	sshtar*) # sshtar://host/sub/dir/or/device
		method=sshtar
		host=$(echo "$f" | sed 's,sshtar://.*@\([^/]*\)/.*$,\1,')
		authkey=$bkd/${host}_sshkey
		authuser=$(echo "$f" | sed 's,sshtar://\(.*\)@.*$,\1,')
		file=$(echo "$f" | sed 's,sshtar://.*@[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			#set -x
			cmd="ssh $sshxtra -C "
			if [ -f $bkd/${host}_sshconfig ]; then
				cmd="$cmd -F $bkd/${host}_sshconfig "
			fi
			cmd="$cmd -i $authkey "
			cmd="$cmd $authuser@$host "
			# would like -O but FreeBSD doesn't have it, bah
			cmd="$cmd sh -c \"cd $file;/bin/pax -Xwv "
			if [ "$nfil" ]; then
				cmd="$cmd -T $(date -r $(stat -f%c "$nfil") +"%y%m%d%H%M.%S") "
			fi
			cmd="$cmd .\""
			log "$cmd $file" > /dev/stderr
			$cmd && echo $successcookie > /dev/stderr
		}
		listmethod() {
			gzip -d < "$outfile" | tar -tvf - | \
				awk '	/^d/	{next} \
					/^\-/	{ $1="";print} \
						{print}'
			if [ -f "${outfile}.stderr" ]; then
				if egrep "^pax: " "${outfile}.stderr" > /dev/null 2>&1; then
					egrep "^pax: " "${outfile}.stderr"  | bubble > /dev/stderr
				fi
			fi
		}
	;;
	dump*) # dump://host/sub/dir/or/device
		method=dump
		host=$(echo "$f" | sed 's,dump://\([^/]*\)/.*$,\1,')
		file=$(echo "$f" | sed 's,dump://[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			cmd="/sbin/dump -h 0 "
			case "`uname -s`" in
			FreeBSD) cmd="$cmd -L ";;
			esac
			if [ "$nfil" ]; then
				cmd="$cmd -T \"\$(date -r $(stat -f%c "$nfil") +"%a %b %e %H:%M:%S %Y")\" "
			fi
			cmd="$cmd -0a -f - $file"
			log "$cmd" > /dev/stderr
			#set -x
			$cmd && echo $successcookie > /dev/stderr
		}
		listmethod() {
			gzip -d < "$outfile" | restore -tyvf - | \
				awk '	/^dir/	{next} \
					/leaf/	{ $1="";print} \
						{print}'
		}
	;;
	sshbackup*) # sshbackup://user@host/sub/dir/or/device
		method=sshbackup
		host=$(echo "$f" | sed 's,sshbackup://.*@\([^/]*\)/.*$,\1,')
		authkey=$bkd/${host}_sshkey
		authuser=$(echo "$f" | sed 's,sshbackup://\(.*\)@.*$,\1,')
		file=$(echo "$f" | sed 's,sshbackup://.*@[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			cmd="ssh $sshxtra -C "
			if [ -f $bkd/${host}_sshconfig ]; then
				cmd="$cmd -F $bkd/${host}_sshconfig "
			fi
			cmd="$cmd -i $authkey "
			cmd="$cmd $authuser@$host "
			cmd="$cmd /usr/sbin/backup -${thisl}uf - $file "
			log "$cmd" > /dev/stderr
			#set -x
			$cmd && echo $successcookie > /dev/stderr
		}
		listmethod() {
			gzip -d < "$outfile" | restore -tvyf - | \
				awk '	/^dir/	{next} \
					/leaf/	{ $1="";print} \
						{print}'
		}
	;;
	sshdump*) # sshdump://user@host/sub/dir/or/device
		method=sshdump
		host=$(echo "$f" | sed 's,sshdump://.*@\([^/]*\)/.*$,\1,')
		authkey=$bkd/${host}_sshkey
		authuser=$(echo "$f" | sed 's,sshdump://\(.*\)@.*$,\1,')
		file=$(echo "$f" | sed 's,sshdump://.*@[^/]*\(/.*\)$,\1,')
		f="$host:$file"
		backupmethod() {
			cmd="ssh $sshxtra -C "
			if [ -f $bkd/${host}_sshconfig ]; then
				cmd="$cmd -F $bkd/${host}_sshconfig "
			fi
			cmd="$cmd -i $authkey "
			cmd="$cmd $authuser@$host "
			cmd="$cmd /sbin/dump -h 0 "
			if [ "$nfil" ]; then
				cmd="$cmd -T \"$(date -r $(stat -f%c "$nfil") +"%a %b %e %H:%M:%S %Y")\" "
			fi
			cmd="$cmd -0a -f - $file"
			log "$cmd" > /dev/stderr
			#set -x
			$cmd && echo $successcookie > /dev/stderr
		}
		listmethod() {
			gzip -d < "$outfile" | restore -tvyf - | \
				awk '	/^dir/	{next} \
					/leaf/	{ $1="";print} \
						{print}'
		}
	;;
	sshafs*) # sshafs://user@host/afsvolume
		method=sshafs
		host=$(echo "$f" | sed 's,sshafs://.*@\([^/]*\)/.*$,\1,')
		authkey=$bkd/${host}_sshkey
		authuser=$(echo "$f" | sed 's,sshafs://\(.*\)@.*$,\1,')
		vol=$(echo "$f" | sed 's,sshafs://.*@[^/]*/\(.*\)$,\1,')
		f="$host:$vol"
		backupmethod() {
			cmd="ssh $sshxtra -C "
			if [ -f $bkd/${host}_sshconfig ]; then
				cmd="$cmd -F $bkd/${host}_sshconfig "
			fi
			cmd="$cmd -i $authkey "
			cmd="$cmd $authuser@$host "
			cmd="$cmd /usr/local/sbin/vos dump $vol "
			if [ "$nfil" ]; then
				cmd="$cmd -time \"$(date -r $(stat -f%c "$nfil") +"%m/%d/%Y %H:%M")\" "
			fi
			cmd="$cmd -verbose -localauth"
			log "$cmd" > /dev/stderr
			$cmd && echo "$successcookie" > /dev/stderr
		}
		listmethod() {
			echo "No listing for sshafs implemented yet"
		}
	;;
	esac
	[ -d $host ] || mkdir $host
	fn="$(echo "$f" | sed 's,//,,;s,[/:],_,g')"

	# Do level `0' if it does not already exist
	[ -f "$host/$fn.0" -a -f "$host/$fn.0.timestamp" ] || thisl=0

	high=-1
	tmp=-1
	nopt=""
	nfil=""
	#echo "$f calculating level: req/high/tmp = $thisl/$high/$tmp"
	case $((thisl+0)) in
	0)
		nopt=""
		nfil=""
	;;
	1)
		nopt="N"
		nfil="$host/$fn.0.timestamp"
		lastl=0
	;;
	[2-9])
		# find the newest backup lower than the current level
		# and if there is a timestamp file, use it to backup to the
		# current level
		high=$((thisl-1))
		tmp=$((thisl-2))
		while [ tmp -ge 0 ]; do
			#echo "$f calculating level: req/high/tmp = $thisl/$high/$tmp"
			tmpfile="$host/${fn}.${tmp}.timestamp"
			highfile="$host/${fn}.${high}.timestamp"
			if [ -f "$tmpfile" -a -f "$highfile" ] && \
			    [ "$tmpfile" -nt "$highfile" ]; then
				high=$tmp
			fi
			let tmp=tmp-1
		done
		if [ -f "$host/$fn.$high.timestamp" ]; then
			nopt="N"
			nfil="$host/$fn.$high.timestamp"
			lastl=$high
		else
			if [ -f "$host/$fn.0.timestamp" ]; then
				nopt="N"
				nfil="$host/$fn.0.timestamp"
				lastl=0
			fi
		fi
		#echo "$f calculated level: req/high/tmp = $thisl/$high/$tmp"
	;;
	esac

	aprog=gzip
	aopt=9

	outfile="$fn.$thisl"
	tmpfile="$(mktemp "$datadir/$host/.$outfile.XXXXXXXXXXX")"
	outfile="$datadir/$host/$outfile"
	start=$(date +%s) 
	# XXX make start= be stat of timestamp
	touch "$tmpfile.timestamp"
	log "dumping $f via $method"
	_log "$(date -r $start +"$datefmt")" "Start of this level $thisl"
	case "$thisl" in
	0)
	;;
	[1-9]*)
		_log "$(date -r $(stat -f%c "$nfil") +"$datefmt")" \
			"Start of last level $lastl"
	;;
	esac
	retrycount=0
	#echo "$tmpfile"
	#set -x
	while [ retrycount -le maxretry ]; do
		fail=0
		backupmethod 2> "$tmpfile.stderr" | \
			$aprog -$aopt > "$tmpfile"
		if [ "$(tail -1 "$tmpfile.stderr" | egrep "$successcookie$" 2> /dev/null)" ] && \
			! [ "$(tail "$tmpfile.stderr" | egrep -i "Connection reset by peer|Connection timed out|denied|failed|Command not found|Killed " 2> /dev/null)" ]; then
			rotate "$outfile"
			mv "$tmpfile" "$outfile" && \
			mv "$tmpfile.timestamp" "$outfile.timestamp" && \
			mv "$tmpfile.stderr" "$outfile.stderr" && \
			listmethod 2> /dev/null | $aprog -$aopt > "$outfile.filelist"
		else
			fail=1
			let retrycount=retrycount+1
			[ retrycount -le maxretry ] && log "$f failed, retrying... $retrycount of $maxretry"
			continue
		fi
		if [ "$( tail "$outfile.stderr" | grep "no address associated" )" ]
		then
			fail=1
			echo "DNS failure for $f, Retrying..."
			let retrycount=retrycount+1
			continue
		fi
		break
	done
	stop=$(date +%s)

	if [ -f "$outfile.stderr" -a fail -eq 0 ]; then
		tail -4 "$outfile.stderr" | head -3 | bubble
	else
		if ! [ -f "${tmpfile}.stderr" ]; then
		    {
			echo "Some unknown error occurred, the output file does not exist!"
			echo "Checked:"
			echo "${tmpfile}.stderr"
			echo "${outfile}.stderr"
			ls -l ${outfile}.stderr ${tmpfile}.stderr 2>&1
		    } | bubble
		fi
	fi

	if [ -f "$outfile" -a fail -eq 0 ]; then
		size=$(echo $(stat -f%z "$outfile")+0 | bc)
		ucsize=$( echo $($aprog -d < "$outfile" | wc -c)+0 | bc)
		totsize="$( echo $size + $totsize  | bc)"
		totucsize="$( echo $ucsize + $totucsize | bc )"
		summdate="$(date -r $stop +"$datefmt")"
		_log "$summdate" "Stop  of this level $thisl"
		savedetails $size $ucsize $f $((stop-start))
	else
		if [ -f "$tmpfile.stderr" ]; then
		    {
			echo "   Attempted to write to:"
			echo "$tmpfile"
			echo "   Stderr:"
			cat "$tmpfile.stderr"
		    } | bubble
		fi
		log "Fail  of this level $thisl"
		rm -f "$tmpfile"*
		savedetails -0 -0 $f $((stop-start))
	fi
done
fi

# remotemirror should be of the form
#  mirror://user@host/subdir
if [ "$remotemirror" ]; then
	if [ "$(pgrep -u _backup rsync)" ]; then
		log rsync already running, killing
		pkill -u _backup rsync
		sleep 3
		pkill -9 -u _backup rsync
	fi
	if [ "$(pgrep -u _backup rsync)" ]; then
		log not mirroring, rsync already running and not killable
	else
		user=$(echo $remotemirror|sed 's,mirror://\([^@]*\)@[^/]*/.*$,\1,')
		host=$(echo $remotemirror|sed 's,mirror://[^@]*@\([^/]*\)/.*$,\1,')
		dir=$(echo $remotemirror|sed 's,mirror://[^@]*@[^/]*\(/.*\)$,\1,')
		tmpfile=$(mktemp $datadir/.ssh.XXXXXXXXXXX)
		{
			echo "#!/bin/sh" 
			echo -n "ssh $sshxtra "
			if [ -f $bkd/${host}_sshkey ]; then
				echo -n "-i $bkd/${host}_sshkey "
			fi
			if [ -f $bkd/${host}_sshconfig ]; then
				echo -n "-F $bkd/${host}_sshconfig "
			fi
			echo "\"\$@\""
		} > $tmpfile
		chmod 755 $tmpfile
		[ "$mirrorbw" ] && bwlimit="--bwlimit=$mirrorbw"
		mirrorstart=$(date +%s)
		log "Mirroring backups to $host:$dir"
		/usr/local/bin/rsync -rtqz --partial --inplace $bwlimit -e $tmpfile \
			--exclude=".*" $datadir/. $host:$dir
		rm $tmpfile
		mirrorstop=$(date +%s)
		log "Mirror time $((mirrorstop-mirrorstart))s"
	fi
fi
globalend=$(date +%s)

savedetails $totsize $totucsize Total $((globalend-globalstart))
#cho "1148.64MB  28.71MB  525.62MB  13.14MB  45.76  54.24  0:05:00 Total"
{
echo "  Uncompressed        Compressed       Percent        Time     FileSystem"
echo "data       speed/s  data      speed/s  %      %     HH:MM:SS hostname:/subdir"
echo "$details"
} | bubble
_log "$(date -r $globalend +"$datefmt")" "pid $$: backup of $@ set completed"
